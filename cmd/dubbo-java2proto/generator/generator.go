/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package generator

import (
	"bytes"
	"dubbo.apache.org/dubbo-go/v3/cmd/dubbo-java2proto/util"
	"fmt"
	"os"
	"strings"
)

import (
	"dubbo.apache.org/dubbo-go/v3/cmd/dubbo-java2proto/parser"
)

type Generator struct {
	jp *parser.JavaParser

	buf      bytes.Buffer
	filepath string
}

func NewGenerator(filepath string) *Generator {
	return &Generator{
		filepath: filepath,
	}
}

func (g *Generator) P(v ...any) {
	for _, x := range v {
		fmt.Fprint(&g.buf, x)
	}
	fmt.Fprintln(&g.buf)
}

func (g *Generator) flush() error {
	file, err := os.Create(g.filepath)
	if err != nil {
		return err
	}
	defer file.Close()

	_, err = file.Write(g.buf.Bytes())
	return err
}

func (g *Generator) GenProto(jp *parser.JavaParser) error {
	g.jp = jp

	g.genPreamble()
	g.genPackage()
	g.genImports()
	g.genMessages()
	g.genServices()

	return g.flush()
}

func (g *Generator) genPreamble() {
	g.P("// Code generated by dubbo-java2proto. DO NOT EDIT.")
	g.P()
}

func (g *Generator) genPackage() {
	g.P(`syntax = "proto3";`)
	g.P()

	g.P(fmt.Sprintf("package %s;", getPackage(g.jp.PackageName)))
	g.P()

	g.P(fmt.Sprintf(`option go_package = "%s;%s";`, strings.ReplaceAll(g.jp.PackageName, ".", "/"), getPackage(g.jp.PackageName)))
	g.P()
}

func (g *Generator) genImports() {
	err := createExtend()
	if err != nil {
		panic(err)
	}

	g.P(`import "hessian2_extend/hessian2_extend.proto";`)
	g.P()
}

func (g *Generator) genMessages() {
	for _, c := range g.jp.Classes {
		g.P(fmt.Sprintf("message %s {", c.Name))
		for i, f := range c.Fields {
			// TODO(Yuukirn): support wrapper type
			pt, _ := util.JavaTypeToProtoType(f.Type)
			g.P(fmt.Sprintf("  %s %s = %d;", pt, f.Name, i+1))
		}
		g.P("  option (hessian2_extend.message_extend) = {")
		g.P(fmt.Sprintf(`    java_class_name: "%s";`, g.jp.AddPackagePrefix(c.Name)))
		g.P("  };")
		g.P("}")
		g.P()
	}
}

func (g *Generator) genServices() {
	for _, i := range g.jp.Interfaces {
		g.P(fmt.Sprintf("service %s {", i.Name))
		for _, m := range i.Methods {
			g.P("  option (hessian2_extend.service_extend) = {")
			g.P(fmt.Sprintf(`    interface_name: "%s";`, g.jp.AddPackagePrefix(i.Name)))
			g.P("  };")

			g.P(fmt.Sprintf("  rpc %s(%s) returns (%s) {", m.Name, buildArgs(m.Args, false), m.ReturnType))
			g.P("    option (hessian2_extend.method_extend) = {")
			g.P(fmt.Sprintf(`      method_name: "%s";`, m.Name))
			g.P("    };")
			g.P("  }")
		}
		g.P("}")
	}
}

func getPackage(packageName string) string {
	split := strings.Split(packageName, ".")
	return split[len(split)-1]
}

func buildArgs(args []*parser.Arg, trailingComma bool) string {
	var res string
	for i, arg := range args {
		res += arg.Type
		if i != len(args)-1 || trailingComma {
			res += ", "
		}
	}
	return res
}

var extendFileContent = `
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

package hessian2_extend;

option go_package = "dubbo.apache.org/dubbo-go/v3/proto/hessian2_extend;hessian2_extend";

import "google/protobuf/descriptor.proto";

message Hessian2MessageOptions {
  string java_class_name = 1;
  string reference_path = 2;
  bool is_inheritance = 3;
  bool extend_args = 4;
}

extend google.protobuf.MessageOptions {
  optional Hessian2MessageOptions message_extend = 12345;
}

message Hessian2MethodOptions {
  string method_name = 1;
}

extend google.protobuf.MethodOptions {
  optional Hessian2MethodOptions method_extend = 12345;
}

message Hessian2ServiceOptions {
  string interface_name = 1;
}

extend google.protobuf.ServiceOptions {
  optional Hessian2ServiceOptions service_extend = 12345;
}

message Hessian2EnumOptions {
  string java_class_name = 1;
}

extend google.protobuf.EnumOptions {
  optional Hessian2EnumOptions enum_extend = 12345;
}

message Hessian2FieldOptions {
  bool is_wrapper = 1;
}

extend google.protobuf.FieldOptions {
  optional Hessian2FieldOptions field_extend = 12345;
}`

func createExtend() error {
	_, err := os.Stat("hessian2_extend")
	if os.IsNotExist(err) {
		// create folder
		err = os.Mkdir("hessian2_extend", os.ModePerm)
		if err != nil {
			return err
		}
	}

	_, err = os.Stat("hessian2_extend/hessian2_extend.proto")
	if os.IsExist(err) {
		return nil
	}

	file, err := os.Create("hessian2_extend/hessian2_extend.proto")
	if err != nil {
		return err
	}
	defer file.Close()

	_, err = file.WriteString(extendFileContent)
	if err != nil {
		return err
	}

	return nil
}
