/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package generator

import (
	"html/template"
	"log"
	"strings"
)

import (
	"dubbo.apache.org/dubbo-go/v3/cmd/protoc-gen-go-dubbo/util"
)

var (
	Tpls                   []*template.Template
	TplPreamble            *template.Template
	TplPackage             *template.Template
	TplImport              *template.Template
	TplTotal               *template.Template
	TplTypeCheck           *template.Template
	TplClientInterface     *template.Template
	TplClientInterfaceImpl *template.Template
	TplMethodInfo          *template.Template
	TplHandler             *template.Template
	TplServerInfo          *template.Template
)

func init() {
	var err error
	TplPreamble, err = template.New("preamble").Parse(PreambleTpl)
	if err != nil {
		log.Fatal(err)
	}

	TplPackage, err = template.New("package").Funcs(template.FuncMap{
		"pkg": func(s string) string {
			return strings.ReplaceAll(s, ".", "_")
		},
	}).Parse(PackageTpl)
	if err != nil {
		log.Fatal(err)
	}

	TplImport, err = template.New("import").Parse(ImportTpl)
	if err != nil {
		log.Fatal(err)
	}

	TplTotal, err = template.New("total").Parse(TotalTpl)
	if err != nil {
		log.Fatal(err)
	}

	TplTypeCheck, err = template.New("typeCheck").Parse(TypeCheckTpl)
	if err != nil {
		log.Fatal(err)
	}

	TplClientInterface, err = template.New("clientInterface").Funcs(template.FuncMap{
		"upper": util.ToUpper,
	}).Parse(InterfaceTpl)
	if err != nil {
		log.Fatal(err)
	}

	TplClientInterfaceImpl, err = template.New("clientInterfaceImpl").Funcs(template.FuncMap{
		"lower": util.ToLower,
		"upper": util.ToUpper,
	}).Parse(InterfaceImplTpl)
	if err != nil {
		log.Fatal(err)
	}

	TplMethodInfo, err = template.New("methodInfo").Funcs(template.FuncMap{
		"last": func(index, length int) bool {
			return index == length-1
		},
	}).Parse(MethodInfoTpl)
	if err != nil {
		log.Fatal(err)
	}

	TplHandler, err = template.New("handler").Funcs(template.FuncMap{
		"upper": util.ToUpper,
	}).Parse(HandlerTpl)
	if err != nil {
		log.Fatal(err)
	}

	TplServerInfo, err = template.New("serverInfo").Funcs(template.FuncMap{
		"lower": util.ToLower,
		"upper": util.ToUpper,
	}).Parse(ServiceInfoTpl)
	if err != nil {
		log.Fatal(err)
	}

	Tpls = append(Tpls, TplPreamble)
	Tpls = append(Tpls, TplPackage)
	Tpls = append(Tpls, TplImport)
	Tpls = append(Tpls, TplTotal)
	Tpls = append(Tpls, TplTypeCheck)
	Tpls = append(Tpls, TplClientInterface)
	Tpls = append(Tpls, TplClientInterfaceImpl)
	Tpls = append(Tpls, TplMethodInfo)
	Tpls = append(Tpls, TplHandler)
	Tpls = append(Tpls, TplServerInfo)
}

const (
	PreambleTpl = `// Code generated by protoc-gen-dubbo. DO NOT EDIT.
//
// Source: {{.Source}}
`

	PackageTpl = `package {{pkg .Package}}`

	ImportTpl = `

import (
	"context"
)

import (
	"dubbo.apache.org/dubbo-go/v3"
	"dubbo.apache.org/dubbo-go/v3/client"
	"dubbo.apache.org/dubbo-go/v3/common"
	"dubbo.apache.org/dubbo-go/v3/common/constant"
	"dubbo.apache.org/dubbo-go/v3/server"
)

`

	TotalTpl = `
{{$t := .}}{{range $s := .Services}}
const (
	// {{$s.ServiceName}}Name is the fully-qualified name of the {{$s.ServiceName}} service.
	{{$s.ServiceName}}Name = "{{$s.InterfaceName}}"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
{{range $s.Methods}}	// {{$s.ServiceName}}{{.MethodName}}Procedure is the fully-qualified name of the {{$s.ServiceName}}'s {{.MethodName}} RPC.
	{{$s.ServiceName}}{{.MethodName}}Procedure = "/{{$s.InterfaceName}}/{{.InvokeName}}"
{{end}}){{end}}

`
	TypeCheckTpl = `var ({{$t := .}}{{range $s := .Services}}
	_ {{.ServiceName}} = (*{{.ServiceName}}Impl)(nil){{end}}
)	

`

	InterfaceTpl = `// {{$t := .}}{{range $s := .Services}}{{.ServiceName}} is a client for the {{$s.InterfaceName}} service.
type {{$s.ServiceName}} interface { {{- range $s.Methods}}
	{{upper .MethodName}}(ctx context.Context, req *{{.RequestType}}, opts ...client.CallOption) (*{{.ReturnType}}, error){{end}}
}{{end}}

`

	InterfaceImplTpl = `{{$t := .}}{{range $s := .Services}}// New{{.ServiceName}} constructs a client for the {{$t.Package}}.{{.ServiceName}} service. 
func New{{.ServiceName}}(cli *client.Client, opts ...client.ReferenceOption) ({{.ServiceName}}, error) {
	conn, err := cli.DialWithInfo("{{.InterfaceName}}", &{{.ServiceName}}_ClientInfo, opts...)
	if err != nil {
		return nil, err
	}
	return &{{.ServiceName}}Impl{
		conn: conn,
	}, nil
}

func SetConsumerService(srv common.RPCService) {
	dubbo.SetConsumerServiceWithInfo(srv,&{{.ServiceName}}_ClientInfo)
}

// {{.ServiceName}}Impl implements {{.ServiceName}}.
type {{.ServiceName}}Impl struct {
	conn *client.Connection
}
{{range .Methods}}
func (c *{{$s.ServiceName}}Impl) {{upper .MethodName}}(ctx context.Context, req *{{.RequestType}}, opts ...client.CallOption) (*{{.ReturnType}}, error) {
	resp := new({{.ReturnType}})
	if err := c.conn.CallUnary(ctx, []interface{}{req}, resp, "{{.InvokeName}}", opts...); err != nil {
		return nil, err
	}
	return resp, nil
}
{{end}}{{end}}
`

	MethodInfoTpl = `{{$t := .}}{{range $i, $s := .Services}}var {{.ServiceName}}_ClientInfo = client.ClientInfo{
	InterfaceName: "{{.InterfaceName}}",
	MethodNames:   []string{ {{- range $j, $m := .Methods}}"{{.InvokeName}}"{{if last $j (len $s.Methods)}}{{else}},{{end}}{{end -}} },
	ConnectionInjectFunc: func(dubboCliRaw interface{}, conn *client.Connection) {
		dubboCli := dubboCliRaw.(*{{$s.ServiceName}}Impl)
		dubboCli.conn = conn
	},
}{{end}}

`

	HandlerTpl = `{{$t := .}}{{range $s := .Services}}// {{.ServiceName}}Handler is an implementation of the {{.InterfaceName}} service.
type {{.ServiceName}}Handler interface { {{- range $s.Methods}}
	{{upper .MethodName}}(context.Context, *{{.RequestType}}) (*{{.ReturnType}}, error){{end}}
}

func Register{{.ServiceName}}Handler(srv *server.Server, hdlr {{.ServiceName}}Handler, opts ...server.ServiceOption) error {
	return srv.Register(hdlr, &{{.ServiceName}}_ServiceInfo, opts...)
}

func SetProviderService(srv common.RPCService)  {
	dubbo.SetProviderServiceWithInfo(srv,&{{.ServiceName}}_ServiceInfo)
}{{end}}
`

	ServiceInfoTpl = `{{$t := .}}{{range $s := .Services}}var {{.ServiceName}}_ServiceInfo = server.ServiceInfo{
	InterfaceName: "{{.InterfaceName}}",
	ServiceType:   (*{{.ServiceName}}Handler)(nil),
	Methods: []server.MethodInfo{ {{- range .Methods}}
		{
			Name: "{{.InvokeName}}",
			Type: constant.CallUnary,
			ReqInitFunc: func() interface{} {
				return new({{.RequestType}})
			},
			MethodFunc: func(ctx context.Context, args []interface{}, handler interface{}) (interface{}, error) {
				req := args[0].(*{{.RequestType}})
				res, err := handler.({{$s.ServiceName}}Handler).{{upper .MethodName}}(ctx, req)
				return res, err
			},
		},{{end}}
	},
}{{end}}
`
)
